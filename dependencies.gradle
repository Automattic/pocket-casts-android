final VERSION_CODE_DIFFERENCE_BETWEEN_APP_AND_AUTOMOTIVE = 50000
final VERSION_CODE_DIFFERENCE_BETWEEN_APP_AND_WEAR = 50000 + VERSION_CODE_DIFFERENCE_BETWEEN_APP_AND_AUTOMOTIVE

def secretProperties = loadPropertiesFromFile(file("$rootDir/secret.properties") )
def versionProperties = loadPropertiesFromFile(file("${rootDir}/version.properties"))

static def loadPropertiesFromFile(inputFile) {
    def properties = new Properties()
    if (inputFile.exists()) {
        inputFile.withInputStream { stream ->
            properties.load(stream)
        }
    }
    return properties
}

// Unfortunately we currently need to rely on a property to separate the version code between app & automotive builds.
// This is mainly because the library modules use the version code information from BuildConfig directly instead
// of receiving from the clients.
//
// On the bright side, the difference between the app & automotive modules is a static number, so even if there is
// an issue and the wrong version code information is used, it'd be easy to identify it.
//
// The long term solution is to move the version information out of the `base.gradle` and into the specific
// app & automotive modules and pass this information to the modules that require it.
def isAutomotiveBuild = (project.findProperty("IS_AUTOMOTIVE_BUILD") ?: false).toBoolean()
def isWearBuild = (project.findProperty("IS_WEAR_BUILD") ?: false).toBoolean()
def getVersionCode = {
    def appVersionCode = versionProperties.getProperty("versionCode", null).toInteger()
    if (isAutomotiveBuild) {
        return appVersionCode + VERSION_CODE_DIFFERENCE_BETWEEN_APP_AND_AUTOMOTIVE
    } else if (isWearBuild) {
       return appVersionCode + VERSION_CODE_DIFFERENCE_BETWEEN_APP_AND_WEAR
    }
    return appVersionCode
}
def getVersionName = {
    def versionName = versionProperties.getProperty("versionName", null)
    if (isAutomotiveBuild) {
        return "${versionName}a"
    } else if (isWearBuild) {
        return "${versionName}w"
    }
    return versionName
}

project.ext {
    // Application
    applicationId = 'au.com.shiftyjelly.pocketcasts'

    versionName = getVersionName()
    versionCode = getVersionCode()

    // Android
    minSdkVersion = 23
    minSdkVersionWear = 26
    targetSdkVersion = 33
    compileSdkVersion = 33
    testInstrumentationRunner = 'androidx.test.runner.AndroidJUnitRunner'

    // App Signing
    storeFile = file("$rootDir/${secretProperties.getProperty("signingKeyStoreFile", null)}")
    if (storeFile.exists()) {
        // Use secret properties
        storePassword = secretProperties.getProperty("signingKeyStorePassword", null)
        keyAlias = secretProperties.getProperty("signingKeyAlias", null)
        keyPassword = secretProperties.getProperty("signingKeyPassword", null)
    } else {
        // Check local gradle properties
        def keystoreFilePropertyKey = "pocketcastsKeyStoreFile"
        if (project.hasProperty(keystoreFilePropertyKey)) {
            storeFile = file(project.getProperty(keystoreFilePropertyKey))
            storePassword = project.getProperty("pocketcastsKeyStorePassword")
            keyAlias = project.getProperty("pocketcastsKeyStoreAlias")
            keyPassword = project.getProperty("pocketcastsKeyStoreAliasPassword")
        }
    }
    canSignRelease = storeFile.exists()

    // Secrets
    settingsEncryptSecret = secretProperties.getProperty("pocketcastsSettingsEncryptSecret", "")
    sharingServerSecret = secretProperties.getProperty("pocketcastsSharingServerSecret", "")
    pocketcastsSentryDsn = secretProperties.getProperty("pocketcastsSentryDsn", "")
    googleSignInServerClientId = secretProperties.getProperty("googleSignInServerClientId", "")

    // Library versions
    versionComposeAccompanist = '0.30.1'
    versionGlide = '4.13.2'

    // Automattic library versions
    versionTracks = 'trunk-b3655d42123501a1d9a304789b738610ab4403c8'

    androidLibs = [

            // Glide (image loading) - https://github.com/bumptech/glide
            glide: "com.github.bumptech.glide:glide:$versionGlide",
            glideOkHttp: "com.github.bumptech.glide:okhttp3-integration:$versionGlide",
            glideCompile: "com.github.bumptech.glide:compiler:$versionGlide",
            coil: "io.coil-kt:coil:2.2.1",
            coilCompose: "io.coil-kt:coil-compose:2.2.1",
            // OkHttp (http client) - https://github.com/square/okhttp
            okHttp: "com.squareup.okhttp3:okhttp:4.9.3",
            okHttpLogging: "com.squareup.okhttp3:logging-interceptor:4.9.3",
            // RxJava - https://github.com/ReactiveX/RxAndroid/releases
            rxAndroid: "io.reactivex.rxjava2:rxandroid:2.1.1",
            rxJava: "io.reactivex.rxjava2:rxjava:2.2.21",
            rxRelay: "com.jakewharton.rxrelay2:rxrelay:2.1.1",
            rxKoltin: "io.reactivex.rxjava2:rxkotlin:2.4.0",
            // Lottie
            lottie: "com.airbnb.android:lottie:5.2.0",
            lottieCompose: "com.airbnb.android:lottie-compose:5.2.0",
            // Mockito
            testMockitoAndroid: "org.mockito:mockito-android:4.6.1",
            testMokitoKotlin: "org.mockito.kotlin:mockito-kotlin:4.0.0",
            testMokitoKotlinInline: 'org.mockito:mockito-inline:4.4.0',
            // Protocol Buffers
            // For Android users, it's recommended to use protobuf Java Lite runtime because of its smaller code size.
            // Java Lite runtime also works better with Proguard because it doesn't rely on Java reflection and is optimized
            // to allow as much code stripping as possible.
            protobufKotlinLite: 'com.google.protobuf:protobuf-kotlin-lite:3.23.4',
            protobufJavaLite: 'com.google.protobuf:protobuf-javalite:3.23.4',
            mockWebServer: "com.squareup.okhttp3:mockwebserver:4.9.3",
            // Automattic Tracks
            automatticTracks: "com.automattic:Automattic-Tracks-Android:$versionTracks"
    ]
}
